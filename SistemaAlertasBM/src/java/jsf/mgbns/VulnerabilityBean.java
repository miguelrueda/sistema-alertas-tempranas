package jsf.mgbns;

import jsf.test.*;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.annotation.PostConstruct;
import javax.faces.bean.ManagedBean;
import javax.faces.bean.ManagedProperty;
import javax.faces.bean.SessionScoped;
import org.primefaces.model.DefaultStreamedContent;
import org.primefaces.model.StreamedContent;

/**
 * Bean que se encarga de obtener y representar las vulnerabilidades hacia las
 * vistas
 *
 * @author t41507
 * @version 09.05.2014
 */
@ManagedBean
@SessionScoped
public class VulnerabilityBean implements java.io.Serializable {

    /**
     * Atributos de serialización y Logger
     */
    private static final long serialVersionUID = -1L;
    private static final Logger LOG = Logger.getLogger(VulnerabilityBean.class.getName());
    /**
     * Atributos principales de el Bean
     */
    private List<Vulnerability> vulns;
    private List<Vulnerability> filteredVulns;
    private Vulnerability selectedVuln;
    private List<Vulnerability> vulnArchive;
    private List<Vulnerability> vulnRecents;
    /**
     * Inyección del servicio de vulnerabilidades
     */
    @ManagedProperty("#{vulnerabilityService}")
    private VulnerabilityService service;

    /**
     * Mét odo de inicilización para el bean ¿Necesario? ¿Las listas se podrían
     * obtener por llamada al BEAN?
     *
     */
    @PostConstruct
    public void init() {
        vulns = service.createList(500);
        vulnArchive = service.createList(500);
        vulnRecents = service.createList(50);
    }

    /**
     * Mét odo setter para el servicio de vulnerabilidades
     *
     * @param service un servicio de tipo VulnerabilityService
     */
    public void setService(VulnerabilityService service) {
        this.service = service;
    }

    /**
     * Constructor sin parámetros del Bean
     */
    public VulnerabilityBean() {
    }

    /**
     * ¿SE VA?
     *
     * @return
     */
    public List<Vulnerability> getVulns() {
        return vulns;
    }

    /**
     * Mét odo que se encarga de devolver el archivo de vulnerabilidades A
     * partir 09062014 funcionará solo con vulnerabilidades de 2014
     *
     * @return List con vulnerabilidades correspondientes al 2014
     */
    public List<Vulnerability> getVulnArchive() {
        return vulnArchive;
    }

    /**
     * Mét odo que se encarga de devolver la lista de vulnerabilidades recientes
     * obtenidas por el parser, la fecha puede variar dentro de un rango de
     * pocos días
     *
     * @return List con vulnerabilidades recientes
     */
    public List<Vulnerability> getVulnRecents() {
        return vulnRecents;
    }

    /**
     * Mét odo que devuelve la vulnerabilidad seleccionada con el fin de poder
     * ser visualizada mediante una ventana modal
     *
     * @return Vulnerabilidad del tipo Vulnerability
     */
    public Vulnerability getSelectedVuln() {
        return selectedVuln;
    }

    /**
     * Mét odo setter que se encarga de establecer la vulnerabilidad
     * seleccionada
     *
     * @param selectedVuln vulnerabilidad del tipo Vulnerability
     */
    public void setSelectedVuln(Vulnerability selectedVuln) {
        this.selectedVuln = selectedVuln;
    }

    /**
     * Mét odo que se encarga de devolver la lista filtrada, con respecto al
     * parámetro del usuario
     *
     * @return List de vulnerabilidades cuando se cumple con el criterio o Empty
     * List cuando no se cumple el criterio
     */
    public List<Vulnerability> getFilteredVulns() {
        return filteredVulns;
    }

    /**
     * Mét odo setter que se encarga de establecer la lista filtrada de
     * vulnerabilidades
     *
     * @param filteredVulns List de vulnerabilidades filtrada
     */
    public void setFilteredVulns(List<Vulnerability> filteredVulns) {
        this.filteredVulns = filteredVulns;
    }

    /**
     * Código de prueba
     */
    private static final List<String> refsList;
    private static final List<String> affSwlist;
    private static StreamedContent file;

    static {
        refsList = new ArrayList<>();
        affSwlist = new ArrayList<>();
        for (int i = 0; i < 10; i++) {
            refsList.add("Referencia: " + (i + 1));
            affSwlist.add("SW afectado: " + (i + 1));
        }
        try {
            InputStream stream = VulnerabilityBean.class.getResourceAsStream("CVE20140001.pdf");
            //InputStream flujo = (FacesContext.getCurrentInstance().getExternalContext()).getResourceAsStream("");
            file = new DefaultStreamedContent(stream, "application/pdf", "cve0001.pdf");
        } catch (Exception e) {
            LOG.log(Level.SEVERE, "Error al obtener el flujo del archivo");
        }

    }

    /**
     *
     * @return
     */
    public List<String> getRefsList() {
        return refsList;
    }

    /**
     *
     * @return
     */
    public List<String> getAffSwlist() {
        return affSwlist;
    }

    /**
     *
     * @return
     */
    public StreamedContent getFile() {
        //Procesar
        LOG.log(Level.INFO, "Generando reporte para la vulnerabilidad: {0}", selectedVuln.getName());
        return file;
    }

    /**
     *
     * @param file
     */
    public void setFile(StreamedContent file) {
        VulnerabilityBean.file = file;
    }
}
