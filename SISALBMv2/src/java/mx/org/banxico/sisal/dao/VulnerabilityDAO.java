package mx.org.banxico.sisal.dao;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.text.DateFormat;
import java.util.ArrayList;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;
import java.util.Collections;
import java.util.StringTokenizer;
import java.util.logging.Level;
import java.util.logging.Logger;
import mx.org.banxico.sisal.db.ConnectionFactory;
import mx.org.banxico.sisal.entities.Vulnerabilidad;
import mx.org.banxico.sisal.parser.VulnerabilityParser;
import mx.org.banxico.sisal.parser.entidades.CVE;
import mx.org.banxico.sisal.parser.entidades.CVEReference;
import mx.org.banxico.sisal.parser.entidades.VulnSoftware;

/**
 *
 * @author t41507
 */
public class VulnerabilityDAO {//implements java.io.Serializable {

    /**
     * Atributos de serialización y Logger
     */
    private static final Logger LOG = Logger.getLogger(VulnerabilityDAO.class.getName());
    //private static final long serialVersionUID = -1L;
    /**
     * Atributos del DAO
     */
    Connection connection;
    PreparedStatement pstmt;
    //TODO: Eliminar este atributo
    Statement stmt;
    private int noOfRRecords;
    private int noOfARecords;
    private List<CVE> listaCVE;
    private List<CVE> archivoCVE;
    private VulnerabilityParser mCVEParser;
    private List<String> nombres;

    /**
     *
     */
    public VulnerabilityDAO() {
        //prepararLista();
        //prepararArchivo();
        //TODO: Eliminar este método
        //iniciarNombres();
        //TODO: Iniciar conexión aqui
        //connection = ConnectionFactory.getInstance().getConnection();
    }

    private static Connection getConnection() {
        Connection con = ConnectionFactory.getInstance().getConnection();
        if (con != null) {
            LOG.log(Level.INFO, "Conexi\u00f3n con BD Exitosa: {0}", con.toString());
        }
        return con;
    }

    /**
     *
     * @param offset
     * @param noOfRecords
     * @return
     */
    public List<CVE> retrieveAllCVEs(int offset, int noOfRecords) {
        String query = "SELECT * FROM DB LIMIT " + offset + ", " + noOfRecords;
        List<CVE> cvelist = new ArrayList<CVE>();
        CVE ncve = null;
        try {
            connection = getConnection();
            stmt = connection.createStatement();
            ResultSet rs = stmt.executeQuery(query);
            while (rs.next()) {
                ncve = new CVE(rs.getString("name"));
                ncve.setDescription(rs.getString("description"));
                //TODO: Agregar los restantes
                cvelist.add(ncve);
            }
            rs.close();
            rs = stmt.executeQuery("SELECT FOUND_ROWS()");
            if (rs.next()) {
                this.noOfRRecords = rs.getInt(1);
            }
        } catch (SQLException e) {
            LOG.log(Level.INFO, "Ocurrio una excepci\u00f3n SQL: {0}", e.getMessage());
        } finally {
            try {
                if (stmt != null) {
                    stmt.close();
                }
                if (connection != null) {
                    connection.close();
                }
            } catch (SQLException e) {
                LOG.log(Level.INFO, "Ocurrio una excepci\u00f3n SQL: {0}", e.getMessage());
            }
        }
        return cvelist;
    }

    /**
     *
     * @return
     */
    public int getNoOfRRecords() {
        return noOfRRecords;
    }

    /**
     *
     * @return
     */
    public int getNoOfARecords() {
        return noOfARecords;
    }

    /**
     *
     * @return
     */
    public List<CVE> retrieveAllCVEsFromFile() {
        mCVEParser = new VulnerabilityParser();
        //mCVEParser.setFiltro("");
        List<CVE> cveList = mCVEParser.getListCVE(getClass().getResourceAsStream("/resources/nvdcve-recent.xml"));
        if (cveList.isEmpty()) {
            return new ArrayList<CVE>();
        }
        return cveList;
    }

    private void prepararListaReciente() {
        mCVEParser = new VulnerabilityParser();
        //mCVEParser.setFiltro("");
        listaCVE = mCVEParser.getListCVE(getClass().getResourceAsStream("/resources/nvdcve-recent.xml"));
        if (listaCVE.isEmpty()) {
            listaCVE = new ArrayList<CVE>();
        }
        Collections.sort(listaCVE);
        this.noOfRRecords = listaCVE.size();
    }

    /**
     *
     * @param offset
     * @param noOfRecords
     * @return
     */
    public List<CVE> retrieveRecents(int offset, int noOfRecords) {
        prepararListaReciente();
        List<CVE> temp = new ArrayList<CVE>();
        CVE nCVE;
        for (int i = offset; i < offset + noOfRecords; i++) {
            if (i >= this.noOfRRecords) {
                break;
            }
            nCVE = listaCVE.get(i);
            //LOG.log(Level.INFO, "Agregando: {0}", nCVE.getName());
            temp.add(nCVE);
        }
        return temp;
    }

    /**
     *
     * @param offset
     * @param noOfRecords
     * @return
     */
    public List<CVE> retrieveAll(int offset, int noOfRecords) {
        prepararArchivo();
        List<CVE> temp = new ArrayList<CVE>();
        CVE nCVE;
        for (int i = offset; i < offset + noOfRecords; i++) {
            if (i >= this.noOfARecords) {
                break;
            }
            nCVE = archivoCVE.get(i);
            temp.add(nCVE);
        }
        return temp;
    }

    private void prepararArchivo() {
        mCVEParser = new VulnerabilityParser();
        //mCVEParser.setFiltro("");
        //archivoCVE = mCVEParser.getListCVE(getClass().getResourceAsStream("/resources/nvdcve-2014.xml"));
        List<CVE> dosmildoce = new ArrayList<CVE>();
        dosmildoce = mCVEParser.getListCVE(getClass().getResourceAsStream("/resources/nvdcve-2012.xml"));
        System.out.println("2012 tiene: " + dosmildoce.size() + " vulnerabilidades");
        List<CVE> dosmiltrece = new ArrayList<CVE>();
        dosmiltrece = mCVEParser.getListCVE(getClass().getResourceAsStream("/resources/nvdcve-2013.xml"));
        System.out.println("2013 tiene: " + dosmiltrece.size() + " vulnerabilidades");
        List<CVE> dosmilcatorce = new ArrayList<CVE>();
        dosmilcatorce = mCVEParser.getListCVE(getClass().getResourceAsStream("/resources/nvdcve-2014.xml"));
        System.out.println("2014 tiene: " + dosmilcatorce.size() + " vulnerabilidades");
        archivoCVE = new ArrayList<CVE>();
        //List<CVE> recientes = new ArrayList<CVE>();
        //recientes = mCVEParser.getListCVE(getClass().getResourceAsStream("/resources/nvdcve-recent.xml"));
        //System.out.println("Recientes: " + recientes.size() + " vulnerabilidades");
        archivoCVE.addAll(dosmildoce);
        archivoCVE.addAll(dosmiltrece);
        archivoCVE.addAll(dosmilcatorce);
        //archivoCVE.addAll(recientes);
        Set<CVE> diferentes = new LinkedHashSet<CVE>();
        Set<CVE> duplicados = new LinkedHashSet<CVE>();
        for (CVE cve : archivoCVE) {
            if (diferentes.contains(cve)) {
                duplicados.add(cve);
            } else {
                diferentes.add(cve);
            }
        }
        archivoCVE = new ArrayList<CVE>();
        archivoCVE.addAll(diferentes);
        System.out.println("Entre 2012 y 2014 existen: " + archivoCVE.size() + " vulnerabilidades.");
        if (archivoCVE.isEmpty()) {
            archivoCVE = new ArrayList<CVE>();
        }
        Collections.sort(archivoCVE);
        this.noOfARecords = archivoCVE.size();
    }
    
    /**
     *
     * @return
     */
    public List<CVE> getRecents() {
        prepararListaReciente();
        if (!listaCVE.isEmpty()) {
            return listaCVE;
        }
        return new ArrayList<CVE>();
    }

    /**
     *
     * @return
     */
    public List<CVE> getArchivoCVE() {
        prepararArchivo();
        if (!archivoCVE.isEmpty()) {
            return archivoCVE;
        } 
        return new ArrayList<CVE>();
    }

    /**
     *
     * @param type
     * @param name
     * @return
     */
    public String describirCVE(int type, String name) {
        CVE temp = null;
        StringBuilder sb = new StringBuilder();
        sb.append("<table id=\"tableexport\" border=\"1\">");
        sb.append("<thead>");
        sb.append("<tr>");
        sb.append("<td colspan=\"2\" class=\"vulnHeader\">").append(name).append("</td>");
        sb.append("</tr>");
        sb.append("</thead>");
        if (type == 1) {
            for (CVE cve : listaCVE) {
                if (cve.getName().toString().equals(name)) {
                    temp = cve;
                    LOG.log(Level.INFO, "Vulnerabilidad encontrada: {0}", cve.getName());
                    break;
                }
            }
        } else if (type == 2) {
            for (CVE cve : archivoCVE) {
                if (cve.getName().toString().equals(name)) {
                    temp = cve;
                    LOG.log(Level.INFO, "Vulnerabilidad encontrada: {0}", cve.getName());
                    break;
                }
            }
        }
        sb.append("<tbody>");
        DateFormat df = DateFormat.getDateInstance(DateFormat.LONG);
        sb.append("<tr>");
        sb.append("<td>").append("Fecha de Publicación:").append("</td>").append("<td id=\"pubdate\">").append(df.format(temp.getPublished())).append("</td>");
        sb.append("</tr>");
        sb.append("<tr>");
        sb.append("<td>").append("Fecha de Modificación:").append("</td>").append("<td id=\"moddate\">").append(df.format(temp.getModified())).append("</td>");
        sb.append("</tr>");
        sb.append("<tr>");
        sb.append("<td>Descripción:").append("</td>").append("<td id=\"desc\">").append(temp.getDescription()).append("</td>");
        sb.append("</tr>");
        sb.append("<tr>");
        String severity = "";
        if (temp.getSeverity().equalsIgnoreCase("high")) {
            severity = "Alta";
        } else if (temp.getSeverity().equalsIgnoreCase("medium")) {
            severity = "Media";
        } else if (temp.getSeverity().equalsIgnoreCase("low")) {
            severity = "Baja";
        } else {
            severity = "ND";
        }
        sb.append("<td>").append("Gravedad:").append("</td>").append("<td id=\"criticidad\">").append(severity).append("</td>");
        sb.append("</tr>");
        sb.append("<tr>");
        sb.append("<td>").append("Calificación:").append("</td>").append("<td id=\"cvsscore\">").append(temp.getCVSS().score).append("</td>");
        sb.append("</tr>");
        sb.append("<tr>");
        sb.append("<td>").append("Vector de Ataque:").append("</td>").append("<td>");
        if (!temp.getCVSS().vector.toString().equals("") && !temp.getCVSS().vector.equals("ND")) {
            sb.append(describirVector(temp.getCVSS().vector));
        } else {
            sb.append("<p id=\"cvssvector\">Vector No Disponible</p>");
        }
        sb.append("</td>");
        sb.append("</tr>");
        sb.append("<tr>");
        sb.append("<td>").append("Referencias:").append("</td>").append("<td id='refs'>");
        if (temp.getReferences().size() > 0) {
            sb.append("<table style='border: none;'>");
            for (int i = 0; i < temp.getReferences().size(); i++) {
                sb.append("<tr>");
                sb.append("<td>").append(temp.getReferences().get(i).getSource()).append("</td>");
                sb.append("<td>").append(temp.getReferences().get(i).getUrl()).append("</td>");
                sb.append("</tr>");
            }
            sb.append("</table>");
        } else {
            sb.append("ND");
        }
        sb.append("</td>");
        sb.append("</tr>");
        sb.append("<input id='hiddenRefs' type='hidden' value='").append(parseRefs(temp.getReferences())).append("' />");
        sb.append("<tr>");
        sb.append("<td>").append("Software Vulnerable:").append("</td>");
        sb.append("<td>");
        if (temp.getVuln_soft().size() > 0) {
            sb.append("<table style='border: none;'>");
            sb.append("<thead>");
            sb.append("<tr>");
            sb.append("<td>").append("Proveedor").append("</td>");
            sb.append("<td>").append("Producto").append("</td>");
            sb.append("<td>").append("Versión(es)").append("</td>");
            sb.append("</tr>");
            sb.append("</thead>");
            for (int i = 0; i < temp.getVuln_soft().size(); i++) {
                sb.append("<tr>");
                sb.append("<td>").append(temp.getVuln_soft().get(i).getVendor().toUpperCase()).append("</td>");
                sb.append("<td>").append(temp.getVuln_soft().get(i).getName()).append("</td>");
                sb.append("<td>").append(temp.getVuln_soft().get(i).getVersion().toString()).append("</td>");
                sb.append("</tr>");
            }
            sb.append("</table>");
        } else {
            sb.append("ND");
        }
        sb.append("</td>");
        sb.append("</tr>");
        sb.append("<input id='hiddenSW' type='hidden' value='");
        if (!(temp.getVuln_soft().isEmpty())) {
            sb.append(parseSW(temp.getVuln_soft()));
        } else {
            sb.append("Lista temporalmente vacía.");
        }
        sb.append("' />");
        //Botón de Descarga
        sb.append("<tr>");
        sb.append("<td>").append("Descargar").append("</td>");
        sb.append("<td>");
        sb.append("<button onclick=\"javascript:toPDF(");
        sb.append("\'").append(temp.getName()).append("\'");
        sb.append(")\">");
        sb.append("Versión PDF</button>");
        sb.append("</td>");
        sb.append("</tr>");
        sb.append("</tbody>");
        sb.append("</table>");
        return sb.toString();
    }

    //(AV:[L,A,N]/AC:[H,M,L]/Au:[N,S,M]/C:[N,P,C]/I:[N,P,C]/A:[N,P,C])

    /**
     *
     * @param vector
     * @return
     */
        public String describirVector(String vector) {
        StringTokenizer tokens = new StringTokenizer(vector, "(:/)");
        StringBuilder sb = new StringBuilder();
        int nDatos = tokens.countTokens();
        String[] vec = new String[nDatos];
        int i = 0;
        while (tokens.hasMoreTokens()) {
            vec[i] = tokens.nextToken().toString();
            i++;
        }
        vec[0] = "Vector de Acceso: ";
        if (vec[1].equalsIgnoreCase("L")) {
            vec[1] = "Acceso Local";
        } else if (vec[1].equalsIgnoreCase("A")) {
            vec[1] = "Red Adyacente";
        } else if (vec[1].equalsIgnoreCase("N")) {
            vec[1] = "Red";
        }
        vec[2] = "Complejidad de Acceso: ";
        if (vec[3].equalsIgnoreCase("H")) {
            vec[3] = "Alta";
        } else if (vec[3].equalsIgnoreCase("M")) {
            vec[3] = "Media";
        } else if (vec[3].equalsIgnoreCase("L")) {
            vec[3] = "Baja";
        }
        vec[4] = "Autenticación: ";
        if (vec[5].equalsIgnoreCase("N")) {
            vec[5] = "No requerida";
        } else if (vec[5].equalsIgnoreCase("S")) {
             vec[5] = "Requiere una instancia";
        } else if (vec[5].equalsIgnoreCase("M")) {
            vec[5] = "Requiere múltiples instancias";
        }
        vec[6] = "Impacto en Confidencialidad: ";
        if (vec[7].equalsIgnoreCase("N")) {
            vec[7] = "No tiene";
        } else if (vec[7].equalsIgnoreCase("P")) {
            vec[7] = "Parcial";
        } else if (vec[7].equalsIgnoreCase("C")) {
            vec[7] = "Completo";
        }
        vec[8] = "Impacto en integridad: ";
        //N = None, P = Partial, C = Complete
        if (vec[9].equalsIgnoreCase("N")) {
            vec[9] = "No tiene";
        } else if (vec[9].equalsIgnoreCase("P")) {
            vec[9] = "Parcial";
        } else if (vec[9].equalsIgnoreCase("C")) {
            vec[9] = "Completo";
        }
        vec[10] = "Impacto en Disponibilidad: ";
        // N = None, P = Partial, C = Complete
        if (vec[11].equalsIgnoreCase("N")) {
            vec[11] = "No tiene";
        } else if (vec[11].equalsIgnoreCase("P")) {
            vec[11] = "Parcial";
        } else if (vec[11].equalsIgnoreCase("C")) {
            vec[11] = "Completo";
        }
        sb.append("<table style='border: none;'>");
        sb.append("<tr>").append("<td>Vector Original</td>").append("<td id='cvssvector'>").append(vector).append("</td>").append("</tr>");
        for (int j = 0; j < vec.length; j++) {
            sb.append("<tr>");
            sb.append("<td>").append(vec[j]).append("</td>");
            j++;
            sb.append("<td>").append(vec[j]).append("</td>");
            sb.append("</tr>");
        }
        sb.append("</table>");
        return sb.toString();
    }

    private Object parseSW(List<VulnSoftware> vuln_soft) {
        StringBuilder sb = new StringBuilder();
        for (VulnSoftware sw : vuln_soft) {
            sb.append("Proveedor: ");
            sb.append(sw.getVendor().toUpperCase());
            sb.append(" \nProducto: ");
            sb.append(sw.getName());
            sb.append(" \nVersión(es): ");
            sb.append(sw.getVersion());
            sb.append("/");
        }
        return sb.toString();
    }

    private Object parseRefs(List<CVEReference> references) {
        StringBuilder sb = new StringBuilder();
        for (CVEReference ref : references) {
            sb.append("Source:\t\t");
            sb.append(ref.getSource());
            sb.append("\nURL:\t\t");
            sb.append(ref.getUrl());
            sb.append("¿");
        }
        return sb.toString();
    }

    private int testRows;

    /**
     *
     * @param offset
     * @param noOfRecords
     * @return
     */
    public List<String> getNombres(int offset, int noOfRecords) {
        LOG.log(Level.INFO, "Par\u00e1metros recibidos: {0} y {1}", new Object[]{offset, noOfRecords});
        List<String> temp = new ArrayList<String>();
        String name = "";
        for (int i = offset; i < offset + noOfRecords; i++) {
            if (i >= this.testRows) {
                break;
            }
            name = nombres.get(i);
            temp.add(name);
        }
        return temp;
    }

    /**
     *
     * @return
     */
    public int getTestRows() {
        return testRows;
    }

    /**
     * TODO: Cambiar este método de prueba
     */
    private void iniciarNombres() {
        //Empieza desde offset y trae noOfRecords
        String query = "SELECT * FROM test"; // LIMIT " + offset + ", " + noOfRecords;
        LOG.log(Level.INFO, "Query: {0}", query);
        nombres = new ArrayList<String>();
        String name = "";
        try {
            connection = getConnection();
            stmt = connection.createStatement();
            ResultSet rs = stmt.executeQuery(query);
            int nr = 0;
            while (rs.next()) {
                name = rs.getString("valor");
                nombres.add(name);
                nr++;
            }
            rs.close();
            this.testRows = nr;
        } catch (SQLException e) {
            LOG.log(Level.INFO, "Error al obtener los nombres: {0}", e.getMessage());
        } finally {
            try {
                if (stmt != null) {
                    stmt.close();
                }
                if (connection != null) {
                    connection.close();
                }
            } catch (SQLException e) {
                LOG.log(Level.INFO, "Error al cerrar la conexi\u00f3n: {0}", e.getMessage());
            }
        }
    }
    
    private static final String sqlInsert = "INSERT INTO Vulnerabilidad(idVulnerabilidad, severidad, fecha_publicacion, "
            + "fecha_modificacion, descripcion, calificacion_cvss, vector_cvss) VALUES (?, ?, ?, ?, ?, ?, ?)";
    private static final String sqlUpdate = "UPDATE Vulnerabilidad"
            + " SET severidad = ?, fecha_publicacion = ?, fecha_modificacion = ?, descripcion = ?, calificacion_cvss = ?, vector_cvss = ? "
            + "WHERE idVulnerabilidad = ?";
    private static final String sqlDelete = "DELETE FROM Vulnerabilidad WHERE idVulnerabilidad = ?";
    private static final String sqlRetrieve = "SELECT * FROM Vulnerabilidad";
    
    /**
     *
     * @param vuln
     * @return
     */
    public boolean crearVulnerabilidad(Vulnerabilidad vuln) {
        boolean res = false;
        try {
            pstmt = connection.prepareStatement(sqlInsert);
            pstmt.setString(1, vuln.getIdVulnerabilidad());
            pstmt.setString(2, vuln.getSeveridad());
            pstmt.setDate(3, new java.sql.Date(vuln.getFechaPublicacion().getTime()));
            pstmt.setDate(4, new java.sql.Date(vuln.getFechaModificacion().getTime()));
            pstmt.setString(5, vuln.getDescripcion());
            pstmt.setDouble(6, vuln.getCalificacionCVSS());
            pstmt.setString(7, vuln.getVectorCVSS());
            pstmt.executeUpdate();
            res = true;
        } catch (SQLException e) {
            LOG.log(Level.INFO, "Ocurrio una excepci\u00f3n de SQL: {0}", e.getMessage());
        }
        return res;
    }
    
    /**
     *
     * @param vuln
     * @return
     */
    public boolean editarVulnerabilidad(Vulnerabilidad vuln) {
        boolean res = false;
        try {
            pstmt = connection.prepareStatement(sqlUpdate);
            pstmt.setString(1, vuln.getSeveridad());
            pstmt.setDate(2, new java.sql.Date(vuln.getFechaPublicacion().getTime()));
            pstmt.setDate(3, new java.sql.Date(vuln.getFechaModificacion().getTime()));
            pstmt.setString(4, vuln.getDescripcion());
            pstmt.setDouble(5, vuln.getCalificacionCVSS());
            pstmt.setString(6, vuln.getVectorCVSS());
            pstmt.setString(7, vuln.getIdVulnerabilidad());
            pstmt.executeUpdate();
            res = true;
        } catch (SQLException e) {
            LOG.log(Level.INFO, "Ocurrio una excepci\u00f3n de SQL: {0}", e.getMessage());
        }
        return res;
    }
    
    /**
     *
     * @param idVulnerabilidad
     * @return
     */
    public boolean eliminarVulnerabilidad(String idVulnerabilidad) {
        boolean res = false;
        try {
            pstmt = connection.prepareStatement(sqlDelete);
            pstmt.setString(1, idVulnerabilidad);
            pstmt.executeUpdate();
            res = true;
        } catch (SQLException e) {
            LOG.log(Level.INFO, "Ocurrio una excepci\u00f3n de SQL: {0}", e.getMessage());
        }
        return res;
    }

    /**
     *
     * @param term
     * @return
     */
    public List<CVE> retrieveCVEsLike(String term) {
        List<CVE> likes = new ArrayList<CVE>();
        for (CVE cve : archivoCVE) {
            String cvename = cve.getName().toLowerCase();
            String key = term.toLowerCase();
            if (cvename.contains(key) || cvename.endsWith(key)) {
                likes.add(cve);
            }
        }
        return likes;
    }

    /**
     *
     * @param key
     * @return
     */
    public List<CVE> searchCVE(String key) {
        List<CVE> found = new ArrayList<CVE>();
        Set<CVE> diferentes = new LinkedHashSet<CVE>();
        Set<CVE> duplicados = new LinkedHashSet<CVE>();
        prepararArchivo();
        for (CVE cve : archivoCVE) {
            if (cve.getName().equalsIgnoreCase(key) || cve.getName().endsWith(key) || cve.getName().toLowerCase().contains(key)) {
                found.add(cve);
            }
        }
        for (CVE cve : found) {
            if (diferentes.contains(cve)) {
                duplicados.add(cve);
            } else {
                diferentes.add(cve);
            }
        }
        found = new ArrayList<CVE>();
        found.addAll(diferentes);
        LOG.log(Level.INFO, "Se encontraron: {0} elementos.", found.size());
        if (!found.isEmpty()) {
            return found;
        }
        LOG.log(Level.INFO, "No se encontro la vulnerabilidad: {0}", key);
        return new ArrayList<CVE>();
    }

}
