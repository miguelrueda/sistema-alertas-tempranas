package mx.org.banxico.sisal.dao;

import cve.entidades.CVE;
import cve.parser.CVEParser;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.text.DateFormat;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;
import java.util.logging.Level;
import java.util.logging.Logger;
import mx.org.banxico.sisal.db.ConnectionFactory;

public class VulnerabilityDAO implements java.io.Serializable {

    private static final Logger LOG = Logger.getLogger(VulnerabilityDAO.class.getName());
    private static final long serialVersionUID = -1L;
    Connection connection;
    Statement stmt;
    private int noOfRRecords;
    private int noOfARecords;
    private List<CVE> listaCVE;
    private List<CVE> archivoCVE;
    private CVEParser mCVEParser;

    public VulnerabilityDAO() {
        prepararLista();
        prepararArchivo();
    }

    private static Connection getConnection() {
        Connection con = ConnectionFactory.getInstance().getConnection();
        return con;
    }

    public List<CVE> retrieveAllCVEs(int offset, int noOfRecords) {
        String query = "SELECT * FROM DB LIMIT " + offset + ", " + noOfRecords;
        List<CVE> cvelist = new ArrayList<>();
        CVE ncve = null;
        try {
            connection = getConnection();
            stmt = connection.createStatement();
            ResultSet rs = stmt.executeQuery(query);
            while (rs.next()) {
                ncve = new CVE(rs.getString("name"));
                ncve.setDescription(rs.getString("description"));
                //TODO: Agregar los restantes
                cvelist.add(ncve);
            }
            rs.close();
            rs = stmt.executeQuery("SELECT FOUND_ROWS()");
            if (rs.next()) {
                this.noOfRRecords = rs.getInt(1);
            }
        } catch (SQLException e) {
            LOG.log(Level.INFO, "Ocurrio una excepci\u00f3n SQL: {0}", e.getMessage());
        } finally {
            try {
                if (stmt != null) {
                    stmt.close();
                }
                if (connection != null) {
                    connection.close();
                }
            } catch (SQLException e) {
                LOG.log(Level.INFO, "Ocurrio una excepci\u00f3n SQL: {0}", e.getMessage());
            }
        }
        return cvelist;
    }

    public int getNoOfRRecords() {
        return noOfRRecords;
    }

    public int getNoOfARecords() {
        return noOfARecords;
    }

    public List<CVE> retrieveAllCVEsFromFile() {
        mCVEParser = new CVEParser();
        mCVEParser.setFiltro("");
        List<CVE> cveList = mCVEParser.getListCVE(getClass().getResourceAsStream("/resources/nvdcve-recent.xml"));
        if (cveList.isEmpty()) {
            return new ArrayList<>();
        }
        return cveList;
    }

    private void prepararLista() {
        mCVEParser = new CVEParser();
        mCVEParser.setFiltro("");
        listaCVE = mCVEParser.getListCVE(getClass().getResourceAsStream("/resources/nvdcve-recent.xml"));
        if (listaCVE.isEmpty()) {
            listaCVE = new ArrayList<>();
        }
        this.noOfRRecords = listaCVE.size();
    }

    public List<CVE> retrieveFromList(int offset, int noOfRecords) {
        LOG.log(Level.INFO, "Par\u00e1metros recibidos: {0} y {1}", new Object[]{offset, noOfRecords});
        List<CVE> temp = new ArrayList<>();
        CVE nCVE;
        for (int i = offset; i < offset + noOfRecords; i++) {
            if (i >= this.noOfRRecords) {
                break;
            }
            nCVE = listaCVE.get(i);
            LOG.log(Level.INFO, "Agregando: {0}", nCVE.getName());
            temp.add(nCVE);
        }
        return temp;
    }

    public List<CVE> retrieveFromArList(int offset, int noOfRecords) {
        LOG.log(Level.INFO, "Par\u00e1metros recibidos: {0} y {1}", new Object[]{offset, noOfRecords});
        List<CVE> temp = new ArrayList<>();
        CVE nCVE;
        for (int i = offset; i < offset + noOfRecords; i++) {
            if (i >= this.noOfARecords) {
                break;
            }
            nCVE = archivoCVE.get(i);
            LOG.log(Level.INFO, "Agregando: {0}", nCVE.getName());
            temp.add(nCVE);
        }
        return temp;
    }

    private void prepararArchivo() {
        mCVEParser = new CVEParser();
        mCVEParser.setFiltro("");
        archivoCVE = mCVEParser.getListCVE(getClass().getResourceAsStream("/resources/nvdcve-2014.xml"));
        if (archivoCVE.isEmpty()) {
            archivoCVE = new ArrayList<>();
        }
        this.noOfARecords = archivoCVE.size();
    }

    public String describirCVE(int type, String name) {
        CVE temp = null;
        StringBuilder sb = new StringBuilder();
        sb.append("<table border=\"1\">");
        sb.append("<thead>");
        sb.append("<tr>");
        sb.append("<td colspan=\"2\" class=\"vulnHeader\">").append(name).append("</td>");
        sb.append("</tr>");
        sb.append("</thead>");
        if (type == 1) {
            for (CVE cve : listaCVE) {
                if (cve.getName().toString().equals(name)) {
                    temp = cve;
                    LOG.log(Level.INFO, "Vulnerabilidad encontrada: {0}", cve.getName());
                    break;
                }
            }
        } else if (type == 2) {
            for (CVE cve : archivoCVE) {
                if (cve.getName().toString().equals(name)) {
                    temp = cve;
                    LOG.log(Level.INFO, "Vulnerabilidad encontrada: {0}", cve.getName());
                    break;
                }
            }
        }
        sb.append("<tbody>");
        DateFormat df = DateFormat.getDateInstance(DateFormat.LONG);
        sb.append("<tr>");
        sb.append("<td>").append("Fecha de Publicación:").append("</td>").append("<td>").append(df.format(temp.getPublished())).append("</td>");
        sb.append("</tr>");
        sb.append("<tr>");
        sb.append("<td>").append("Fecha de Modificación:").append("</td>").append("<td>").append(df.format(temp.getModified())).append("</td>");
        sb.append("</tr>");
        sb.append("<tr>");
        sb.append("<td>Descripción:").append("</td>").append("<td>").append(temp.getDescription()).append("</td>");
        sb.append("</tr>");
        sb.append("<tr>");
        sb.append("<td>").append("Criticidad:").append("</td>").append("<td>").append(temp.getSeverity()).append("</td>");
        sb.append("</tr>");
        sb.append("<tr>");
        sb.append("<td>").append("CVSS:").append("</td>").append("<td>").append(temp.getCVSS().score).append("</td>");
        sb.append("</tr>");
        sb.append("<tr>");
        sb.append("<td>").append("Vector CVSS:").append("</td>").append("<td>").append(describirVector(temp.getCVSS().vector)).append("</td>");
        sb.append("</tr>");
        sb.append("<tr>");
        sb.append("<td>").append("Referencias:").append("</td>").append("<td>");
        if (temp.getReferences().size() > 0) {
            sb.append("<table style='border: none;'>");
            for (int i = 0; i < temp.getReferences().size(); i++) {
                sb.append("<tr>");
                sb.append("<td>").append(temp.getReferences().get(i).getSource()).append("</td>");
                sb.append("<td>").append(temp.getReferences().get(i).getUrl()).append("</td>");
                sb.append("</tr>");
            }
            sb.append("</table>");
        } else {
            sb.append("ND");
        }
        sb.append("</td>");
        sb.append("</tr>");
        sb.append("<tr>");
        sb.append("<td>").append("Software Vulnerable:").append("</td>");
        sb.append("<td>");
        if (temp.getVuln_soft().size() > 0) {
            sb.append("<table style='border: none;'>");
            sb.append("<thead>");
            sb.append("<tr>");
            sb.append("<td>").append("Proveedor").append("</td>");
            sb.append("<td>").append("Producto").append("</td>");
            sb.append("<td>").append("Versión(es)").append("</td>");
            sb.append("</tr>");
            sb.append("</thead>");
            for (int i = 0; i < temp.getVuln_soft().size(); i++) {
                sb.append("<tr>");
                sb.append("<td>").append(temp.getVuln_soft().get(i).getVendor().toUpperCase()).append("</td>");
                sb.append("<td>").append(temp.getVuln_soft().get(i).getName()).append("</td>");
                sb.append("<td>").append(temp.getVuln_soft().get(i).getVersion().toString()).append("</td>");
                sb.append("</tr>");
            }
            sb.append("</table>");
        } else {
            sb.append("ND");
        }
        sb.append("</td>");
        sb.append("</tr>");
        sb.append("</tbody>");
        sb.append("</table>");
        return sb.toString();
    }

    //(AV:[L,A,N]/AC:[H,M,L]/Au:[N,S,M]/C:[N,P,C]/I:[N,P,C]/A:[N,P,C])
    private String describirVector(String vector) {
        StringTokenizer tokens = new StringTokenizer(vector, "(:/)");
        StringBuilder sb = new StringBuilder();
        int nDatos = tokens.countTokens();
        String[] vec = new String[nDatos];
        int i = 0;
        while (tokens.hasMoreTokens()) {
            vec[i] = tokens.nextToken().toString();
            i++;
        }
        vec[0] = "Vector de Acceso: ";
        switch (vec[1].toString()) {
            case "L":
                vec[1] = "Acceso Local";
                break;
            case "A":
                vec[1] = "Red Adyacente";
                break;
            case "N":
                vec[1] = "Red";
                break;
        }
        vec[2] = "Complejidad de Acceso: ";
        switch (vec[3].toString()) {
            case "H":
                vec[3] = "Alta";
                break;
            case "M":
                vec[3] = "Media";
                break;
            case "L":
                vec[3] = "Baja";
                break;
        }
        vec[4] = "Autenticación: ";
        switch (vec[5].toString()) {
            case "N":
                vec[5] = "No requerida";
                break;
            case "S":
                vec[5] = "Requiere una instancia";
                break;
            case "M":
                vec[5] = "Requiere múltiples instancias";
                break;
        }
        vec[6] = "Impacto en Confidencialidad: ";
        switch (vec[7].toString()) {
            case "N":
                vec[7] = "No tiene";
                break;
            case "P":
                vec[7] = "Parcial";
                break;
            case "C":
                vec[7] = "Completo";
                break;
        }
        vec[8] = "Impacto en integridad: ";
        //N = None, P = Partial, C = Complete
        switch (vec[9].toString()) {
            case "N":
                vec[9] = "No tiene";
                break;
            case "P":
                vec[9] = "Parcial";
                break;
            case "C":
                vec[9] = "Completo";
                break;
        }
        vec[10] = "Impacto en Disponibilidad: ";
        // N = None, P = Partial, C = Complete
        switch (vec[11].toString()) {
            case "N":
                vec[11] = "No tiene";
                break;
            case "P":
                vec[11] = "Parcial";
                break;
            case "C":
                vec[11] = "Completo";
                break;
        }
        sb.append("<table style='border: none;'>");
        for (int j = 0; j < vec.length; j++) {
            sb.append("<tr>");
            sb.append("<td>").append(vec[j]).append("</td>");
            j++;
            sb.append("<td>").append(vec[j]).append("</td>");
            sb.append("</tr>");
        }
        sb.append("</table>");
        return sb.toString();
    }

}
