package org.banxico.ds.sisal.dao;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.net.URL;
import java.net.MalformedURLException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.text.DateFormat;
import java.util.ArrayList;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;
import java.util.Collections;
import java.util.StringTokenizer;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.banxico.ds.sisal.db.ConnectionFactory;
import org.banxico.ds.sisal.entities.Vulnerabilidad;
import org.banxico.ds.sisal.parser.VulnerabilityParser;
import org.banxico.ds.sisal.parser.entidades.CVE;
import org.banxico.ds.sisal.parser.entidades.CVEReference;
import org.banxico.ds.sisal.parser.entidades.VulnSoftware;

/**
 * Clase que se encarga de manejar el acceso a datos relacionados con la entidad
 * Vulnerabilidad
 *
 * @author t41507
 * @version 07.08.2014
 */
public class VulnerabilityDAO {

    /**
     * Atributo LOGGER
     */
    private static final Logger LOG = Logger.getLogger(VulnerabilityDAO.class.getName());
    /**
     * Atributos de Conexión
     */
    Connection connection;
    PreparedStatement pstmt;
    //TODO: Eliminar este atributo
    Statement stmt;
    /**
     * Atributos del DAO
     */
    private VulnerabilityParser mCVEParser;
    private int cantidadRecientes;
    private int cantidadArchivo;
    private List<CVE> listaRecientes;
    private List<CVE> listaArchivo;
    private List<String> nombres;
    private Path readPath;
    /**
     * Consultas SQL
     */
    private static final String getURLQuery = "SELECT url FROM FuenteApp WHERE idFuenteApp = ?";
    private static final String sqlInsert = "INSERT INTO Vulnerabilidad(idVulnerabilidad, severidad, fecha_publicacion, "
            + "fecha_modificacion, descripcion, calificacion_cvss, vector_cvss) VALUES (?, ?, ?, ?, ?, ?, ?)";
    private static final String sqlUpdate = "UPDATE Vulnerabilidad"
            + " SET severidad = ?, fecha_publicacion = ?, fecha_modificacion = ?, descripcion = ?, calificacion_cvss = ?, vector_cvss = ? "
            + "WHERE idVulnerabilidad = ?";
    private static final String sqlDelete = "DELETE FROM Vulnerabilidad WHERE idVulnerabilidad = ?";
    private static final String sqlRetrieve = "SELECT * FROM Vulnerabilidad";

    /**
     * Constructor
     */
    public VulnerabilityDAO() {
    }

    /**
     * Método para obtener la conexión a BD
     *
     * @return objeto de tipo Conexión que contiene la conexión a la BD
     */
    private static Connection getConnection() {
        Connection con = ConnectionFactory.getInstance().getConnection();
        return con;
    }

    /**
     * GETTER
     *
     * @return cantidad de vulnerabilidades recientes
     */
    public int obtenerCantidadRecientes() {
        return cantidadRecientes;
    }

    /**
     * GETTER
     *
     * @return cantidad del archivo de vulnerabilidades
     */
    public int obtenerCantidadArchivo() {
        return cantidadArchivo;
    }

    /**
     * Método que retorna la lista de vulnerabilidades recientes
     *
     * @return lista con todas las vulnerabildiades recientes
     */
    public List<CVE> obtenerListaRecientes() {
        prepararListaReciente();
        if (!listaRecientes.isEmpty()) {
            return listaRecientes;
        }
        return new ArrayList<CVE>();
    }

    /**
     * Método que retorna la lista de archivo de vulnerabilidades
     *
     * @return lista con todas las vulnerabildiades del archivo
     */
    public List<CVE> obtenerListaArchivo() {
        prepararArchivo();
        if (!listaArchivo.isEmpty()) {
            return listaArchivo;
        }
        return new ArrayList<CVE>();
    }

    /**
     * Método que se encarga de obtener la url de una fuente
     *
     * @param id llave de la fuente a buscar
     * @return url de la fuente seleccionada
     */
    private String obtenerURL(int id) {
        String url = "";
        try {
            //Obtener conexión y preparar statement
            connection = getConnection();
            pstmt = connection.prepareStatement(getURLQuery);
            pstmt.setInt(1, id);
            ResultSet rs = pstmt.executeQuery();
            //Iterar el resultado
            while (rs.next()) {
                url = rs.getString(1);
            }
            LOG.log(Level.INFO, "La url obtenida es: {0}", url);
        } catch (SQLException ex) {
            LOG.log(Level.SEVERE, "ocurrio un error al obtener la URL {0}: {1}", new Object[]{id, ex.getMessage()});
        }
        return url;
    }

    /**
     * Método que se encarga de obtener una lista de vulnerabilidades recientes
     *
     * @param offset variable de inicio
     * @param noregs cantidad de registros
     * @return lista con la cantidad de vulnerabilidades indicada
     */
    public List<CVE> obtenerDeRecientes(int offset, int noregs) {
        //Inicializar la lista de vulnerabilidades reciente
        prepararListaReciente();
        //Instanciar una lista y un objeto de vulnerabilidad
        List<CVE> temp = new ArrayList<CVE>();
        CVE nCVE;
        //Iterar la lista de vulnerabildades para retornar las solicitadas
        for (int i = offset; i < offset + noregs; i++) {
            if (i >= this.cantidadRecientes) {
                break;
            }
            nCVE = listaRecientes.get(i);
            temp.add(nCVE);
        }
        return temp;
    }

    /**
     * Método que se encarga de inicializar la lista de vulnerabilidades
     */
    private void prepararListaReciente() {
        try {
            //Inicializar el parser
            mCVEParser = new VulnerabilityParser();
            //Obtener URL de DB
            String dburl = obtenerURL(1);
            //URL url = new URL("http://nvd.nist.gov/download/nvdcve-recent.xml");
            URL url = new URL(dburl);
            /**
             * En caso de no contar con acceso a internet realizarlo de manera
             * local
             *
             * listaCVE =
             * mCVEParser.getListCVE(getClass().getResourceAsStream("/resources/nvdcve-recent.xml"));
             */
            listaRecientes = mCVEParser.getListCVE(url.openStream());
            if (listaRecientes.isEmpty()) {
                listaRecientes = new ArrayList<CVE>();
            }
            //Ordenar la lista de vulnerabilidades
            Collections.sort(listaRecientes);
            this.cantidadRecientes = listaRecientes.size();
        } catch (MalformedURLException ex) {
            LOG.log(Level.SEVERE, "La URL está malformada: {0}", ex.getMessage());
        } catch (IOException ex) {
            LOG.log(Level.SEVERE, "ocurrio un problema al obtener el flujo de la URL: {0}", ex.getMessage());
        }
    }
    
    /**
     * Método que se encarga de retornar el archivo de vulnerabilidades
     *
     * @param offset registro de inicio
     * @param noOfRecords cantidad de registros
     * @return lista con la cantidad de vulnerabilidades solicitada
     */
    public List<CVE> obtenerDeArchivo(int offset, int noOfRecords) {
        //Inicializar la lista de archivo
        prepararArchivo();
        //Instaciar una lista de vulnerabilidades y un objeto de tipo CVE
        List<CVE> temp = new ArrayList<CVE>();
        CVE nCVE;
        for (int i = offset; i < offset + noOfRecords; i++) {
            if (i >= this.cantidadArchivo) {
                break;
            }
            //Agregar el elemtno a la lista
            nCVE = listaArchivo.get(i);
            temp.add(nCVE);
        }
        return temp;
    }
    
    /**
     * Método que se encarga de inicializar la lista de archivo
     */
    private void prepararArchivo() {
        String root = readPath.getRoot().toString();
        String subdir = readPath.subpath(0, 2).toString();
        //Inicializar el parser
        mCVEParser = new VulnerabilityParser();
        //archivoCVE = mCVEParser.getListCVE(getClass().getResourceAsStream("/resources/nvdcve-2014.xml"));
        //Intanciar una lista para 2013 y una para 2014
        List<CVE> dosmiltrece = new ArrayList<CVE>();
        String readDir = root + subdir + File.separator + "vulnerabilidades" + File.separator;
        //File file = new File(root + subdir + File.separator + "vulnerabilidades" + File.separator + "nvdcve-2013.xml");
        File file = new File(readDir + "nvdcve-2013.xml");
        try {
            //dosmiltrece = mCVEParser.getListCVE(getClass().getResourceAsStream("/resources/nvdcve-2013.xml"));
            dosmiltrece = mCVEParser.getListCVE(new FileInputStream(file));
        } catch (FileNotFoundException ex) {
            LOG.log(Level.SEVERE, "No se encontro el archivo de 2013: {0}", ex.getMessage());
        }
        file = null;
        file = new File(readDir + "nvdcve-2014.xml");
        List<CVE> dosmilcatorce = new ArrayList<CVE>();
        try {
            //dosmilcatorce = mCVEParser.getListCVE(getClass().getResourceAsStream("/resources/nvdcve-2014.xml"));
            dosmilcatorce = mCVEParser.getListCVE(new FileInputStream(file));
        } catch (FileNotFoundException ex) {
            LOG.log(Level.SEVERE, "No se encontro el archivo de 2014: {0}", ex.getMessage());
        }
        //Inicializar la lista de archivo y agregar las 2 listas anteriores
        listaArchivo = new ArrayList<CVE>();
        listaArchivo.addAll(dosmiltrece);
        listaArchivo.addAll(dosmilcatorce);
        //Instanciar 2 conjuntos para eliminar los elementos duplicados
        Set<CVE> diferentes = new LinkedHashSet<CVE>();
        Set<CVE> duplicados = new LinkedHashSet<CVE>();
        //Iterar todo el archivo, y buscar elementos repetidos
        for (CVE cve : listaArchivo) {
            if (diferentes.contains(cve)) {
                duplicados.add(cve);
            } else {
                diferentes.add(cve);
            }
        }
        //Reiniciar la lista de archivo y agregar solo los elementos diferentes
        listaArchivo = new ArrayList<CVE>();
        listaArchivo.addAll(diferentes);
        if (listaArchivo.isEmpty()) {
            listaArchivo = new ArrayList<CVE>();
        }
        //Ordenar los elementos y establecer la cantiodad de vulnerabilidades
        Collections.sort(listaArchivo);
        this.cantidadArchivo = listaArchivo.size();
    }

    /**
     * Método que se encarga de describir a detalle una vulnerabidad
     *
     * @param tipo el tipo de vulnerabilidad 1 para recientes 2 para archivo
     * @param name nombre de la vulnerabilidad
     * @return retorna un flujo para presentarlo en la vista
     */
    public String describirCVE(int tipo, String name) {
        //Instanciar un objeto de tipo CVE
        CVE temp = null;
        //Instanciar el buffer
        StringBuilder sb = new StringBuilder();
        //Codigo HTML
        sb.append("<table id=\"tableexport\" border=\"1\">");
        sb.append("<thead>");
        sb.append("<tr>");
        sb.append("<td colspan=\"2\" class=\"vulnHeader\">").append(name).append("</td>");
        sb.append("</tr>");
        sb.append("</thead>");
        //Buscar la vulnerabilidad en las listas a partir del parametro tipo
        if (tipo == 1) {
            for (CVE cve : listaRecientes) {
                if (cve.getName().toString().equals(name)) {
                    temp = cve;
                    break;
                }
            }
        } else if (tipo == 2) {
            for (CVE cve : listaArchivo) {
                if (cve.getName().toString().equals(name)) {
                    temp = cve;
                    break;
                }
            }
        }
        //Codigo HTML
        sb.append("<tbody>");
        DateFormat df = DateFormat.getDateInstance(DateFormat.LONG);
        sb.append("<tr>");
        sb.append("<td>").append("Fecha de Publicación:").append("</td>").append("<td id=\"pubdate\">").append(df.format(temp.getPublished())).append("</td>");
        sb.append("</tr>");
        sb.append("<tr>");
        sb.append("<td>").append("Fecha de Modificación:").append("</td>").append("<td id=\"moddate\">").append(df.format(temp.getModified())).append("</td>");
        sb.append("</tr>");
        sb.append("<tr>");
        sb.append("<td>Descripción:").append("</td>").append("<td id=\"desc\">").append(temp.getDescription()).append("</td>");
        sb.append("</tr>");
        sb.append("<tr>");
        //Traducción de la gravedad de la vulnerabilidad
        String severity = "";
        if (temp.getSeverity().equalsIgnoreCase("high")) {
            severity = "Alta";
        } else if (temp.getSeverity().equalsIgnoreCase("medium")) {
            severity = "Media";
        } else if (temp.getSeverity().equalsIgnoreCase("low")) {
            severity = "Baja";
        } else {
            severity = "ND";
        }
        //Codigo HTML
        sb.append("<td>").append("Gravedad:").append("</td>").append("<td id=\"criticidad\">").append(severity).append("</td>");
        sb.append("</tr>");
        sb.append("<tr>");
        sb.append("<td>").append("Calificación:").append("</td>").append("<td id=\"cvsscore\">").append(temp.getCVSS().score).append("</td>");
        sb.append("</tr>");
        sb.append("<tr>");
        sb.append("<td>").append("Vector de Ataque:").append("</td>").append("<td>");
        //Descripción del Vector de la vulnerabilidad
        if (!temp.getCVSS().vector.toString().equals("") && !temp.getCVSS().vector.equals("ND")) {
            sb.append(describirVector(temp.getCVSS().vector));
        } else {
            sb.append("<p id=\"cvssvector\">Vector No Disponible</p>");
        }
        sb.append("</td>");
        sb.append("</tr>");
        sb.append("<tr>");
        //Lista de referencias
        sb.append("<td>").append("Referencias:").append("</td>").append("<td id='refs'>");
        if (temp.getReferences().size() > 0) {
            sb.append("<table style='border: none;'>");
            for (int i = 0; i < temp.getReferences().size(); i++) {
                sb.append("<tr>");
                sb.append("<td>").append(temp.getReferences().get(i).getSource()).append("</td>");
                sb.append("<td>").append(temp.getReferences().get(i).getUrl()).append("</td>");
                sb.append("</tr>");
            }
            sb.append("</table>");
        } else {
            sb.append("ND");
        }
        sb.append("</td>");
        sb.append("</tr>");
        sb.append("<input id='hiddenRefs' type='hidden' value='").append(parseRefs(temp.getReferences())).append("' />");
        sb.append("<tr>");
        sb.append("<td>").append("Software Vulnerable:").append("</td>");
        sb.append("<td>");
        //Lista de Software Vulnerable
        if (temp.getVuln_soft().size() > 0) {
            sb.append("<table style='border: none;'>");
            sb.append("<thead>");
            sb.append("<tr>");
            sb.append("<td>").append("Proveedor").append("</td>");
            sb.append("<td>").append("Producto").append("</td>");
            sb.append("<td>").append("Versión(es)").append("</td>");
            sb.append("</tr>");
            sb.append("</thead>");
            for (int i = 0; i < temp.getVuln_soft().size(); i++) {
                sb.append("<tr>");
                sb.append("<td>").append(temp.getVuln_soft().get(i).getVendor().toUpperCase()).append("</td>");
                sb.append("<td>").append(temp.getVuln_soft().get(i).getName()).append("</td>");
                sb.append("<td>").append(temp.getVuln_soft().get(i).getVersion().toString()).append("</td>");
                sb.append("</tr>");
            }
            sb.append("</table>");
        } else {
            sb.append("ND");
        }
        //Codigo HTML
        sb.append("</td>");
        sb.append("</tr>");
        sb.append("<input id='hiddenSW' type='hidden' value='");
        if (!(temp.getVuln_soft().isEmpty())) {
            sb.append(parseSW(temp.getVuln_soft()));
        } else {
            sb.append("Lista temporalmente vacía.");
        }
        sb.append("' />");
        //Botón de Descarga
        sb.append("<tr>");
        sb.append("<td>").append("Descargar").append("</td>");
        sb.append("<td>");
        sb.append("<button onclick=\"javascript:toPDF(");
        sb.append("\'").append(temp.getName()).append("\'");
        sb.append(")\">");
        sb.append("Versión PDF</button>");
        sb.append("</td>");
        sb.append("</tr>");
        sb.append("</tbody>");
        sb.append("</table>");
        return sb.toString();
    }

    /**
     * Método que se encarga de realizar la descripción de un vector de ataque
     * Un vector de ataque puede ser de la forma:
     * (AV:[L,A,N]/AC:[H,M,L]/Au:[N,S,M]/C:[N,P,C]/I:[N,P,C]/A:[N,P,C])
     *
     * @param vector la representación del vector como cadena
     * @return cadena con la descripción del vector
     */
    public String describirVector(String vector) {
        //Partir la cadena original por los caracteres (:/)
        StringTokenizer tokens = new StringTokenizer(vector, "(:/)");
        StringBuilder sb = new StringBuilder();
        int nDatos = tokens.countTokens();
        String[] vec = new String[nDatos];
        int i = 0;
        while (tokens.hasMoreTokens()) {
            vec[i] = tokens.nextToken().toString();
            i++;
        }
        vec[0] = "Vector de Acceso: ";
        if (vec[1].equalsIgnoreCase("L")) {
            vec[1] = "Acceso Local";
        } else if (vec[1].equalsIgnoreCase("A")) {
            vec[1] = "Red Adyacente";
        } else if (vec[1].equalsIgnoreCase("N")) {
            vec[1] = "Red";
        }
        vec[2] = "Complejidad de Acceso: ";
        if (vec[3].equalsIgnoreCase("H")) {
            vec[3] = "Alta";
        } else if (vec[3].equalsIgnoreCase("M")) {
            vec[3] = "Media";
        } else if (vec[3].equalsIgnoreCase("L")) {
            vec[3] = "Baja";
        }
        vec[4] = "Autenticación: ";
        if (vec[5].equalsIgnoreCase("N")) {
            vec[5] = "No requerida";
        } else if (vec[5].equalsIgnoreCase("S")) {
            vec[5] = "Requiere una instancia";
        } else if (vec[5].equalsIgnoreCase("M")) {
            vec[5] = "Requiere múltiples instancias";
        }
        vec[6] = "Impacto en Confidencialidad: ";
        if (vec[7].equalsIgnoreCase("N")) {
            vec[7] = "No tiene";
        } else if (vec[7].equalsIgnoreCase("P")) {
            vec[7] = "Parcial";
        } else if (vec[7].equalsIgnoreCase("C")) {
            vec[7] = "Completo";
        }
        vec[8] = "Impacto en integridad: ";
        //N = None, P = Partial, C = Complete
        if (vec[9].equalsIgnoreCase("N")) {
            vec[9] = "No tiene";
        } else if (vec[9].equalsIgnoreCase("P")) {
            vec[9] = "Parcial";
        } else if (vec[9].equalsIgnoreCase("C")) {
            vec[9] = "Completo";
        }
        vec[10] = "Impacto en Disponibilidad: ";
        // N = None, P = Partial, C = Complete
        if (vec[11].equalsIgnoreCase("N")) {
            vec[11] = "No tiene";
        } else if (vec[11].equalsIgnoreCase("P")) {
            vec[11] = "Parcial";
        } else if (vec[11].equalsIgnoreCase("C")) {
            vec[11] = "Completo";
        }
        sb.append("<table style='border: none;'>");
        sb.append("<tr>")
                .append("<td>Vector Original</td>")
                .append("<td id='cvssvector'>")
                .append(vector)
                .append("</td>")
                .append("</tr>");
        for (int j = 0; j < vec.length; j++) {
            sb.append("<tr>");
            sb.append("<td>")
                    .append(vec[j])
                    .append("</td>");
            j++;
            sb.append("<td>")
                    .append(vec[j])
                    .append("</td>");
            sb.append("</tr>");
        }
        sb.append("</table>");
        return sb.toString();
    }

    /**
     * Método que se encarga de representar como cadena los objetos de tipo
     * Software de la lista de software vulnerable
     *
     * @param vuln_soft Lista de software vulnerable
     * @return buffer con la representación de un objeto software
     */
    private Object parseSW(List<VulnSoftware> vuln_soft) {
        StringBuilder sb = new StringBuilder();
        for (VulnSoftware sw : vuln_soft) {
            sb.append("Proveedor: ");
            sb.append(sw.getVendor().toUpperCase());
            sb.append(" \nProducto: ");
            sb.append(sw.getName());
            sb.append(" \nVersión(es): ");
            sb.append(sw.getVersion());
            sb.append("/");
        }
        return sb.toString();
    }

    /**
     * Método que se encarga de representar como cadena los objetos de tipo
     * referencia de la lista de referencias
     *
     * @param references lista de referencias
     * @return buffer con la representación de la referencia
     */
    private Object parseRefs(List<CVEReference> references) {
        StringBuilder sb = new StringBuilder();
        for (CVEReference ref : references) {
            sb.append("Source:\t\t");
            sb.append(ref.getSource());
            sb.append("\nURL:\t\t");
            sb.append(ref.getUrl());
            sb.append("¿");
        }
        return sb.toString();
    }

    //Operaciones CRUD
    /**
     * Método que se encarga de registrar una vulnerabilidad en la BD
     *
     * @param vuln objeto de tipo vulnerabilidad a guardar
     * @return bandera con el resultado de la operación
     */
    public boolean crearVulnerabilidad(Vulnerabilidad vuln) {
        boolean res = false;
        try {
            //Obtener conexión y preparar el statement
            connection = getConnection();
            pstmt = connection.prepareStatement(sqlInsert);
            pstmt.setString(1, vuln.getIdVulnerabilidad());
            pstmt.setString(2, vuln.getSeveridad());
            pstmt.setDate(3, new java.sql.Date(vuln.getFechaPublicacion().getTime()));
            pstmt.setDate(4, new java.sql.Date(vuln.getFechaModificacion().getTime()));
            pstmt.setString(5, vuln.getDescripcion());
            pstmt.setDouble(6, vuln.getCalificacionCVSS());
            pstmt.setString(7, vuln.getVectorCVSS());
            //Ejecutar inserción
            pstmt.executeUpdate();
            res = true;
        } catch (SQLException e) {
            LOG.log(Level.INFO, "Ocurrio una excepci\u00f3n de SQL: {0}", e.getMessage());
        } finally {
            try {
                if (pstmt != null) {
                    pstmt.close();
                }
                if (connection != null) {
                    connection.close();
                }
            } catch (SQLException e) {
                LOG.log(Level.INFO, "Ocurrio una excepci\u00f3n al cerrar la conexi\u00f3n: {0}", e.getMessage());
            }
        }
        return res;
    }

    /**
     * Método que se encarga de realizar la edición de una vulnerabiliddad
     *
     * @param vuln vulnerabilidad a editar
     * @return bandera con el resultado de la ejecución de la vulnerabilidad
     */
    public boolean editarVulnerabilidad(Vulnerabilidad vuln) {
        boolean res = false;
        try {
            //obtener conexión y preparar el statement
            connection = getConnection();
            pstmt = connection.prepareStatement(sqlUpdate);
            pstmt.setString(1, vuln.getSeveridad());
            pstmt.setDate(2, new java.sql.Date(vuln.getFechaPublicacion().getTime()));
            pstmt.setDate(3, new java.sql.Date(vuln.getFechaModificacion().getTime()));
            pstmt.setString(4, vuln.getDescripcion());
            pstmt.setDouble(5, vuln.getCalificacionCVSS());
            pstmt.setString(6, vuln.getVectorCVSS());
            pstmt.setString(7, vuln.getIdVulnerabilidad());
            //Realizar la edición
            pstmt.executeUpdate();
            res = true;
        } catch (SQLException e) {
            LOG.log(Level.INFO, "Ocurrio una excepci\u00f3n de SQL: {0}", e.getMessage());
        } finally {
            try {
                if (pstmt != null) {
                    pstmt.close();
                }
                if (connection != null) {
                    connection.close();
                }
            } catch (SQLException e) {
                LOG.log(Level.INFO, "Ocurrio una excepci\u00f3n al cerrar la conexi\u00f3n: {0}", e.getMessage());
            }
        }
        return res;
    }

    /**
     * Método que se encarga de eliminar una vulnerabilidad a partir de su id
     *
     * @param idVulnerabilidad nombre de la vulnerabilidad
     * @return bandera con el resultado de la ejecución
     */
    public boolean eliminarVulnerabilidad(String idVulnerabilidad) {
        boolean res = false;
        try {
            //Obtener conexión y preparar el statement
            connection = getConnection();
            pstmt = connection.prepareStatement(sqlDelete);
            pstmt.setString(1, idVulnerabilidad);
            //Ejecutar la eliminación
            pstmt.executeUpdate();
            res = true;
        } catch (SQLException e) {
            LOG.log(Level.INFO, "Ocurrio una excepci\u00f3n de SQL: {0}", e.getMessage());
        } finally {
            try {
                if (pstmt != null) {
                    pstmt.close();
                }
                if (connection != null) {
                    connection.close();
                }
            } catch (SQLException e) {
                LOG.log(Level.INFO, "Ocurrio una excepci\u00f3n al cerrar la conexi\u00f3n: {0}", e.getMessage());
            }
        }
        return res;
    }

    /**
     * Método que implementa una función 'LIKE' de SQL para obtener
     * coincidencias
     *
     * @param term referencia de la vulnerabilidad
     * @return lista de vulnerabilidades que cumplen el criterio
     */
    public List<CVE> retrieveCVEsLike(String term) {
        List<CVE> likes = new ArrayList<CVE>();
        for (CVE cve : listaArchivo) {
            //Si el nombre de la vulnerabilidad se parece al de la clave agregarla a la lista
            String cvename = cve.getName().toLowerCase();
            String key = term.toLowerCase();
            if (cvename.contains(key) || cvename.endsWith(key)) {
                likes.add(cve);
            }
        }
        return likes;
    }

    /**
     * Método que se encarga de buscar una vulnerabilidad
     *
     * @param key clave de la busqueda
     * @return lista de vulnerabilidades que cumplen el criterio
     */
    public List<CVE> searchCVE(String key) {
        //Instanciar una lista para el resultado y 2 conjuntos para eliminar duplicados
        List<CVE> found = new ArrayList<CVE>();
        Set<CVE> diferentes = new LinkedHashSet<CVE>();
        Set<CVE> duplicados = new LinkedHashSet<CVE>();
        prepararArchivo();
        //Buscar la coincidencia
        for (CVE cve : listaArchivo) {
            if (cve.getName().equalsIgnoreCase(key) || cve.getName().endsWith(key) || cve.getName().toLowerCase().contains(key)) {
                LOG.log(Level.INFO, "A\u00f1adiendo a resultados: {0}", cve.getName());
                found.add(cve);
            }
        }
        //En caso de existir duplicados eliminarlos
        for (CVE cve : found) {
            if (diferentes.contains(cve)) {
                duplicados.add(cve);
            } else {
                diferentes.add(cve);
            }
        }
        //Reiniciar la lista de vulnerabilidades y agregarle las diferentes
        found = new ArrayList<CVE>();
        found.addAll(diferentes);
        if (!found.isEmpty()) {
            return found;
        }
        return new ArrayList<CVE>();
    }

    /**
     * CÓDIGO BASURA
     */
    /**
     *
     * @param offset
     * @param noOfRecords
     * @return
     */
    public List<CVE> retrieveAllCVEs(int offset, int noOfRecords) {
        String query = "SELECT * FROM DB LIMIT " + offset + ", " + noOfRecords;
        List<CVE> cvelist = new ArrayList<CVE>();
        CVE ncve = null;
        try {
            connection = getConnection();
            stmt = connection.createStatement();
            ResultSet rs = stmt.executeQuery(query);
            while (rs.next()) {
                ncve = new CVE(rs.getString("name"));
                ncve.setDescription(rs.getString("description"));
                //TODO: Agregar los restantes
                cvelist.add(ncve);
            }
            rs.close();
            rs = stmt.executeQuery("SELECT FOUND_ROWS()");
            if (rs.next()) {
                this.cantidadRecientes = rs.getInt(1);
            }
        } catch (SQLException e) {
            LOG.log(Level.INFO, "Ocurrio una excepci\u00f3n SQL: {0}", e.getMessage());
        } finally {
            try {
                if (stmt != null) {
                    stmt.close();
                }
                if (connection != null) {
                    connection.close();
                }
            } catch (SQLException e) {
                LOG.log(Level.INFO, "Ocurrio una excepci\u00f3n SQL: {0}", e.getMessage());
            }
        }
        return cvelist;
    }

    /**
     *
     * @return
     */
    public List<CVE> retrieveAllCVEsFromFile() {
        mCVEParser = new VulnerabilityParser();
        //mCVEParser.setFiltro("");
        List<CVE> cveList = mCVEParser.getListCVE(getClass().getResourceAsStream("/resources/nvdcve-recent.xml"));
        if (cveList.isEmpty()) {
            return new ArrayList<CVE>();
        }
        return cveList;
    }

    private int testRows;

    /**
     * ¿?
     *
     * @return
     */
    public int getTestRows() {
        return testRows;
    }

    /**
     * ¿?
     *
     * @param offset referencia de inicio
     * @param noregs cantidad de registros a devolver
     * @return
     */
    public List<String> getNombres(int offset, int noregs) {
        List<String> temp = new ArrayList<String>();
        String name = "";
        for (int i = offset; i < offset + noregs; i++) {
            if (i >= this.testRows) {
                break;
            }
            name = nombres.get(i);
            temp.add(name);
        }
        return temp;
    }

    /**
     * TODO: Cambiar este método de prueba
     */
    private void iniciarNombres() {
        //Empieza desde offset y trae noOfRecords
        String query = "SELECT * FROM test"; // LIMIT " + offset + ", " + noOfRecords;
        LOG.log(Level.INFO, "Query: {0}", query);
        nombres = new ArrayList<String>();
        String name = "";
        try {
            connection = getConnection();
            stmt = connection.createStatement();
            ResultSet rs = stmt.executeQuery(query);
            int nr = 0;
            while (rs.next()) {
                name = rs.getString("valor");
                nombres.add(name);
                nr++;
            }
            rs.close();
            this.testRows = nr;
        } catch (SQLException e) {
            LOG.log(Level.INFO, "Error al obtener los nombres: {0}", e.getMessage());
        } finally {
            try {
                if (stmt != null) {
                    stmt.close();
                }
                if (connection != null) {
                    connection.close();
                }
            } catch (SQLException e) {
                LOG.log(Level.INFO, "Error al cerrar la conexi\u00f3n: {0}", e.getMessage());
            }
        }
    }

    public Path getReadPath() {
        return readPath;
    }

    public void setReadPath(Path readPath) {
        this.readPath = readPath;
    }

}
